######################################################################
#
# UCF file for ML501 PAR
#
######################################################################

#------------------------------------------------------------------------------
# ZBT SSRAM controller multi-cycle path constraints (ssram_controller)
#------------------------------------------------------------------------------

# Define the two clock domains as timespecs
#NET dcm0_clkdv TNM_NET="wb_clk";
#TIMESPEC "TS_wb_clk" = PERIOD "wb_clk" 20 ns HIGH 10;
#NET dcm0_clk0 TNM_NET = "ssram_clk200";
#TIMESPEC "TS_ssram_clk200" = PERIOD "ssram_clk200" "TS_wb_clk" / 4;

# Now define their relationship - logic should be configured so that there's
# 1 WB cycle at all times before anything is sampled across domains
#TIMESPEC "TS_wb_clk_ssram_clk200" = from "wb_clk" TO "ssram_clk200" 15 ns;
#TIMESPEC "TS_ssram_clk200_wb_clk" = from "ssram_clk200" TO "wb_clk" 15 ns;

#------------------------------------------------------------------------------
# Pins used
#------------------------------------------------------------------------------

# 100MHz fixed freq clock.
#NET sys_clk_in LOC = AD8; 
#NET sys_clk_in IOSTANDARD = LVCMOS33;
#NET "sys_clk_in" TNM_NET = "sys_clk_in"; 
#TIMESPEC "TS_sys_clk_in" = PERIOD "sys_clk_in" 10 ns HIGH 50.00%; 

NET sys_clk_in_p LOC = E16;
NET sys_clk_in_n LOC = E17;
NET sys_clk_in_p IOSTANDARD = LVDS_25;
NET sys_clk_in_n IOSTANDARD = LVDS_25;
INST *sys_clk_in_ibufds DIFF_TERM=TRUE;

NET "clkgen0/sys_clk_in_200" TNM_NET = "sys_clk_in_200";
TIMESPEC "TSSYSCLK200" = PERIOD "sys_clk_in_200" 5 ns HIGH 50 %;


NET rst_n_pad_i LOC = T23 | IOSTANDARD = LVDCI_33;
NET rst_n_pad_i PULLUP;
NET rst_n_pad_i TIG;


#------------------------------------------------------------------------------
# User Reset pins (hook up so user can reset system from processor)
#------------------------------------------------------------------------------

#NET usr_rst_out LOC = P20 | IOSTANDARD = LVCMOS25; # HDR2_62
#NET usr_rst_out PULLUP;
#NET usr_rst_out TIG;
#NET usr_rst_in LOC = P21 | IOSTANDARD = LVCMOS25; # HDR2_64
#NET usr_rst_in PULLUP;
#NET usr_rst_in TIG;

#------------------------------------------------------------------------------
# All pins for ML501
#------------------------------------------------------------------------------

#NET "sys_clk_s" TNM_NET = "sys_clk";
#TIMESPEC "TSSYSCLK" = PERIOD "sys_clk" 10 ns HIGH 50 %;
#NET "sys_clk_in_200" TNM_NET = "sys_clk_in_200";
#TIMESPEC "TSSYSCLK200" = PERIOD "sys_clk_in_200" 5 ns HIGH 50 %;

#NET sys_clk_in_p LOC = E16;
#NET sys_clk_in_n LOC = E17;
#NET sys_clk_in_p IOSTANDARD = LVDS_25;
#NET sys_clk_in_n IOSTANDARD = LVDS_25;
#INST *sys_clk_in_ibufds DIFF_TERM=TRUE;

#NET sys_rst_pin LOC = T23 | IOSTANDARD = LVCMOS33 | PULLUP;

#NET Interrupt TIG;

# Reset timing ignore - treat as async paths
#NET sys_rst_s TIG;
#NET opb_v20_0_OPB_Rst TIG;
#NET lmb_v10_1_OPB_Rst TIG;
#NET lmb_v10_0_OPB_Rst TIG;
#NET opb_v20_0_Debug_SYS_Rst TIG;
#NET plb_v34_0_PLB_Rst TIG;
#NET dcm_locked TIG;

#------------------------------------------------------------------------------
# OpenCores JTAG Debug signals and User UART on EXP Header pins
#------------------------------------------------------------------------------

NET uart0_srx_expheader_pad_i  LOC = F25; # HDR2_2
NET uart0_srx_expheader_pad_i TIG;
NET uart0_srx_expheader_pad_i PULLUP;
NET uart0_srx_expheader_pad_i IOSTANDARD = LVCMOS25;

NET uart0_stx_expheader_pad_o  LOC = F24; # HDR2_4
NET uart0_stx_expheader_pad_o TIG;
NET uart0_stx_expheader_pad_o PULLUP;
NET uart0_stx_expheader_pad_o IOSTANDARD = LVCMOS25;

NET tdo_pad_o  LOC = E26; # HDR2_6
NET tdi_pad_i  LOC = E25; # HDR2_8
NET tms_pad_i  LOC = G22; # HDR2_10
NET tck_pad_i  LOC = G21; # HDR2_12

NET tdo_pad_o  TIG; NET tdo_pad_o  PULLUP; NET tdo_pad_o  IOSTANDARD = LVCMOS25;
NET tdi_pad_i  TIG; NET tdi_pad_i  PULLUP; NET tdi_pad_i  IOSTANDARD = LVCMOS25;
NET tms_pad_i  TIG; NET tms_pad_i  PULLUP; NET tms_pad_i  IOSTANDARD = LVCMOS25;
NET tck_pad_i  TIG; NET tck_pad_i  PULLUP; NET tck_pad_i  IOSTANDARD = LVCMOS25;
# Overide the following mapping error: 
# ERROR:Place:645 - A clock IOB clock component is not placed at an optimal clock
# IOB site.
NET "tck_pad_i" CLOCK_DEDICATED_ROUTE = FALSE;

#////////////////////////////////////////////////////////////////////////////
#// Buttons, LEDs, Piezo, and DIP Switches 
#////////////////////////////////////////////////////////////////////////////

# GPLED
NET gpio0_io<0>  LOC = E11; #GPLED7 (Rightmost - LSB)
NET gpio0_io<1>  LOC = E10; #GPLED6
NET gpio0_io<2>  LOC = E15; #GPLED5
NET gpio0_io<3>  LOC = D15; #GPLED4
NET gpio0_io<4> LOC = F12; #GPLED3
NET gpio0_io<5> LOC = E12; #GPLED2
NET gpio0_io<6> LOC = D14; #GPLED1
NET gpio0_io<7> LOC = E13; #GPLED0 (Leftmost - MSB)

NET gpio0_io<0>  IOSTANDARD = LVCMOS25;
NET gpio0_io<1>  IOSTANDARD = LVCMOS25;
NET gpio0_io<2>  IOSTANDARD = LVCMOS25;
NET gpio0_io<3>  IOSTANDARD = LVCMOS25;
NET gpio0_io<4>  IOSTANDARD = LVCMOS25;
NET gpio0_io<5>  IOSTANDARD = LVCMOS25;
NET gpio0_io<6>  IOSTANDARD = LVCMOS25;
NET gpio0_io<7>  IOSTANDARD = LVCMOS25;

# North-East-South-West-Center LEDs
NET gpio0_io<8>  LOC = T22;  # C LED
NET gpio0_io<9>  LOC = AA18; # W LED
NET gpio0_io<10>  LOC = AA8;  # S LED
NET gpio0_io<11>  LOC = Y18;  # E LED
NET gpio0_io<12>  LOC = Y8;   # N LED
NET gpio0_io<8> IOSTANDARD = LVCMOS33;
NET gpio0_io<9> IOSTANDARD = LVCMOS33;
NET gpio0_io<10> IOSTANDARD = LVCMOS33;
NET gpio0_io<11> IOSTANDARD = LVCMOS33;
NET gpio0_io<12> IOSTANDARD = LVCMOS33;

# North-East-South-West-Center Buttons
NET gpio0_io<13>  LOC = B21; # C Button
NET gpio0_io<14> LOC = C21; # W Button
NET gpio0_io<15> LOC = B22; # S Button
NET gpio0_io<16> LOC = A23; # E Button
NET gpio0_io<17> LOC = A22; # N Button
NET gpio0_io<13>  IOSTANDARD = LVCMOS33;
NET gpio0_io<14> IOSTANDARD = LVCMOS33;
NET gpio0_io<15> IOSTANDARD = LVCMOS33;
NET gpio0_io<16> IOSTANDARD = LVCMOS33;
NET gpio0_io<17> IOSTANDARD = LVCMOS33;

# Dip Switches 1-8
NET gpio0_io<18> LOC = T7; # DIP SW 8
NET gpio0_io<19> LOC = U7; # DIP SW 7
NET gpio0_io<20> LOC = U5; # DIP SW 6
NET gpio0_io<21> LOC = U6; # DIP SW 5
NET gpio0_io<22> LOC = T5; # DIP SW 4
NET gpio0_io<23> LOC = T4; # DIP SW 3
#NET gpio0_io<24> LOC = V3; # DIP SW 2
#NET gpio0_io<25> LOC = U4; # DIP SW 1
NET gpio0_io<18> IOSTANDARD = LVCMOS18;
NET gpio0_io<19> IOSTANDARD = LVCMOS18;
NET gpio0_io<20> IOSTANDARD = LVCMOS18;
NET gpio0_io<21> IOSTANDARD = LVCMOS18;
NET gpio0_io<22> IOSTANDARD = LVCMOS18;
NET gpio0_io<23> IOSTANDARD = LVCMOS18;
#NET gpio0_io<24> IOSTANDARD = LVCMOS18;
#NET gpio0_io<25> IOSTANDARD = LVCMOS18;

#SMA Connectors
#NET gpio0_io<22> LOC = F10; # SMA_IN_N
#NET gpio0_io<23> LOC = F9;  # SMA_IN_P
#NET gpio0_io<24> LOC = F19; # SMA_OUT_N
#NET gpio0_io<25> LOC = E18; # SMA_OUT_P
#NET gpio0_io<26> LOC = AD8; # USERCLK
#NET gpio0_io<22> IOSTANDARD = LVCMOS25;
#NET gpio0_io<23> IOSTANDARD = LVCMOS25;
#NET gpio0_io<24> IOSTANDARD = LVCMOS25;
#NET gpio0_io<25> IOSTANDARD = LVCMOS25;
#NET gpio0_io<26> IOSTANDARD = LVCMOS33;

NET "gpio0_io<*>" PULLDOWN;
NET "gpio0_io<*>" TIG;
NET "gpio0_io<*>" SLEW = SLOW;
NET "gpio0_io<*>" DRIVE = 2;

#NET "gpio0_io<22>" SLEW = FAST;
#NET "gpio0_io<22>" DRIVE = 12;
#NET "gpio0_io<23>" SLEW = FAST;
#NET "gpio0_io<23>" DRIVE = 12;
#NET "gpio0_io<24>" SLEW = FAST;
#NET "gpio0_io<24>" DRIVE = 12;
#NET "gpio0_io<25>" SLEW = FAST;
#NET "gpio0_io<25>" DRIVE = 12;

## #NET  "gpio2_d_out<*>" TIG;
## #NET  "gpio2_t_out<*>" TIG;
## NET  "gpio2_in<*>" TIG;

## NET  "piezo" LOC = V1;
## NET  "piezo" IOSTANDARD = LVCMOS18;
## NET  "piezo" TIG;

## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for PS/2 Ports
## #------------------------------------------------------------------------------

## #Keyboard
## NET ps2_keyb_clk  LOC = J1;
## NET ps2_keyb_clk  SLEW = SLOW;
## NET ps2_keyb_clk  DRIVE = 2;
## NET ps2_keyb_clk  IOSTANDARD = LVCMOS18;
## NET ps2_keyb_clk  TIG;
## NET ps2_keyb_data LOC = H2;
## NET ps2_keyb_data SLEW = SLOW;
## NET ps2_keyb_data DRIVE = 2;
## NET ps2_keyb_data IOSTANDARD = LVCMOS18;
## NET ps2_keyb_data TIG;

## #Mouse
## NET ps2_mouse_clk  LOC = L2;
## NET ps2_mouse_clk  SLEW = SLOW;
## NET ps2_mouse_clk  DRIVE = 2;
## NET ps2_mouse_clk  IOSTANDARD = LVCMOS18;
## NET ps2_mouse_clk  TIG;
## NET ps2_mouse_data LOC = K1;
## NET ps2_mouse_data SLEW = SLOW;
## NET ps2_mouse_data DRIVE = 2;
## NET ps2_mouse_data IOSTANDARD = LVCMOS18;
## NET ps2_mouse_data TIG;

## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for IIC Controller
## #------------------------------------------------------------------------------

# General I2C bus

NET i2c0_scl_io    LOC = R20;
NET i2c0_sda_io    LOC = T20;
NET i2c0_scl_io    SLEW = SLOW;
NET i2c0_scl_io    DRIVE = 6;
NET i2c0_scl_io    TIG;
NET i2c0_scl_io    IOSTANDARD = LVCMOS33;
NET i2c0_sda_io    SLEW = SLOW;
NET i2c0_sda_io    DRIVE = 6;
NET i2c0_sda_io    TIG;
NET i2c0_sda_io    IOSTANDARD = LVCMOS33;

# DDR2 I2C bus

NET i2c1_scl_io  LOC = Y7;
NET i2c1_sda_io  LOC = AA7;
NET i2c1_scl_io  SLEW = SLOW;
NET i2c1_scl_io  DRIVE = 6;
NET i2c1_scl_io  TIG;
NET i2c1_scl_io  IOSTANDARD = LVCMOS18;
NET i2c1_sda_io  SLEW = SLOW;
NET i2c1_sda_io  DRIVE = 6;
NET i2c1_sda_io  TIG;
NET i2c1_sda_io  IOSTANDARD = LVCMOS18;

## #------------------------------------------------------------------------------
## # IO Pad Locations Constraints for SPI memory
## #------------------------------------------------------------------------------

#NET spi0_mosi_o  LOC = AA9  | IOSTANDARD = LVCMOS33 | DRIVE = 6 | SLEW = FAST | TIG;
#NET spi0_ss_o<0>  	 LOC = AC14 | IOSTANDARD = LVCMOS33 | DRIVE = 6 | SLEW = FAST | TIG;
# These go through the STARTUP_VIRTEX5 block - don't worry about assigning them
# here.
#NET spi0_miso_i  LOC = K11 | IOSTANDARD = LVCMOS33 | DRIVE = 6 | SLEW = FAST | TIG;

#NET spi0_sck_o   LOC = J10 | IOSTANDARD = LVCMOS33 | DRIVE = 6 | SLEW = FAST | TIG;

## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for System ACE MPU / USB
## #------------------------------------------------------------------------------

## NET sysace_clk_in   LOC        = AB12;
## NET sysace_clk_in   IOSTANDARD = LVCMOS33;
## NET sysace_clk_in   TNM_NET    = "sysace_clk_in";
## # Leave 1 ns margin
## TIMESPEC "TSSYSACE" = PERIOD "sysace_clk_in" 29 ns;

## NET sace_usb_a<0>   LOC        = N6;
## NET sace_usb_a<1>   LOC        = E5;
## NET sace_usb_a<2>   LOC        = F5;
## NET sace_usb_a<3>   LOC        = F4;
## NET sace_usb_a<4>   LOC        = J5;
## NET sace_usb_a<5>   LOC        = E7;
## NET sace_usb_a<6>   LOC        = G7;
## NET sace_usb_a<*>   IOSTANDARD = LVCMOS33;
## NET sace_usb_a<*>   SLEW       = FAST;
## NET sace_usb_a<*>   DRIVE      = 8;
## NET sace_mpce       LOC        = F7;
## NET sace_mpce       IOSTANDARD = LVCMOS33;
## NET sace_mpce       SLEW       = FAST;
## NET sace_mpce       DRIVE      = 8;
## NET sace_usb_d<0>   LOC        = M6;
## NET sace_usb_d<1>   LOC        = K5;
## NET sace_usb_d<2>   LOC        = L3;
## NET sace_usb_d<3>   LOC        = L4;
## NET sace_usb_d<4>   LOC        = L7;
## NET sace_usb_d<5>   LOC        = L5;
## NET sace_usb_d<6>   LOC        = H6;
## NET sace_usb_d<7>   LOC        = G5;
## NET sace_usb_d<8>   LOC        = M7;
## NET sace_usb_d<9>   LOC        = H7;
## NET sace_usb_d<10>  LOC        = J6;
## NET sace_usb_d<11>  LOC        = G4;
## NET sace_usb_d<12>  LOC        = K7;
## NET sace_usb_d<13>  LOC        = J4;
## NET sace_usb_d<14>  LOC        = H4;
## NET sace_usb_d<15>  LOC        = K6;
## NET sace_usb_d<*>   IOSTANDARD = LVCMOS33;
## NET sace_usb_d<*>   SLEW       = FAST;
## NET sace_usb_d<*>   DRIVE      = 8;
## NET sace_usb_d<*>   PULLDOWN;
## NET sace_usb_oen    LOC        = E6;
## NET sace_usb_oen    IOSTANDARD = LVCMOS33;
## NET sace_usb_oen    SLEW       = FAST;
## NET sace_usb_oen    DRIVE      = 8;
## NET sace_usb_wen    LOC        = M5;
## NET sace_usb_wen    IOSTANDARD = LVCMOS33;
## NET sace_usb_wen    SLEW       = FAST;
## NET sace_usb_wen    DRIVE      = 8;
## NET sysace_mpirq    LOC        = G6;
## NET sysace_mpirq    IOSTANDARD = LVCMOS33;
## NET sysace_mpirq    TIG;
## NET sysace_mpirq    PULLDOWN;

## NET usb_csn         LOC        = N3;
## NET usb_csn         IOSTANDARD = LVCMOS33;
## NET usb_csn         SLEW       = FAST;
## NET usb_csn         DRIVE      = 8;
## NET usb_hpi_reset_n LOC        = P3;
## NET usb_hpi_reset_n IOSTANDARD = LVCMOS33;
## NET usb_hpi_reset_n TIG;
## NET usb_hpi_int     LOC        = M4;
## NET usb_hpi_int     IOSTANDARD = LVCMOS33;
## NET usb_hpi_int     TIG;
## NET usb_hpi_int     PULLDOWN;

## ////////////////////////////////////////////////////////////////////////////
## // Misc Board Signals
## ////////////////////////////////////////////////////////////////////////////

## NET plb_error LOC = N4; # Bus Error 1
## NET plb_error IOSTANDARD = LVCMOS33;
## NET plb_error TIG;
## NET opb_error LOC = P5; # Bus Error 2
## NET opb_error IOSTANDARD = LVCMOS33;
## NET opb_error TIG;

## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for Expansion Header GPIO
## #------------------------------------------------------------------------------

## NET gpio_exp_hdr1<31> LOC = AB26; # HDR1_64
## NET gpio_exp_hdr1<30> LOC = AC26; # HDR1_62
## NET gpio_exp_hdr1<29> LOC = AA25; # HDR1_60
## NET gpio_exp_hdr1<28> LOC = P26;  # HDR1_58
## NET gpio_exp_hdr1<27> LOC = Y26; # HDR1_56
## NET gpio_exp_hdr1<26> LOC = Y25; # HDR1_54
## NET gpio_exp_hdr1<25> LOC = W26; # HDR1_52
## NET gpio_exp_hdr1<24> LOC = W25; # HDR1_50
## NET gpio_exp_hdr1<23> LOC = U25; # HDR1_48
## NET gpio_exp_hdr1<22> LOC = U24; # HDR1_46
## NET gpio_exp_hdr1<21> LOC = T25; # HDR1_44
## NET gpio_exp_hdr1<20> LOC = T24; # HDR1_42
## NET gpio_exp_hdr1<19> LOC = P24; # HDR1_40
## NET gpio_exp_hdr1<18> LOC = P25; # HDR1_38
## NET gpio_exp_hdr1<17> LOC = N26; # HDR1_36
## NET gpio_exp_hdr1<16> LOC = AB25; # HDR1_34
## NET gpio_exp_hdr1<15> LOC = M24; # HDR1_32
## NET gpio_exp_hdr1<14> LOC = N24; # HDR1_30
## NET gpio_exp_hdr1<13> LOC = M25; # HDR1_28
## NET gpio_exp_hdr1<12> LOC = M26; # HDR1_26
## NET gpio_exp_hdr1<11> LOC = K25; # HDR1_24
## NET gpio_exp_hdr1<10> LOC = K26; # HDR1_22
## NET gpio_exp_hdr1<9>  LOC = L24; # HDR1_20
## NET gpio_exp_hdr1<8>  LOC = L25; # HDR1_18
## NET gpio_exp_hdr1<7>  LOC = M21; # HDR1_16
## NET gpio_exp_hdr1<6>  LOC = K21; # HDR1_14
## NET gpio_exp_hdr1<5>  LOC = K20; # HDR1_12
## NET gpio_exp_hdr1<4>  LOC = M22; # HDR1_10
## NET gpio_exp_hdr1<3>  LOC = H23; # HDR1_8
## NET gpio_exp_hdr1<2>  LOC = J21; # HDR1_6
## NET gpio_exp_hdr1<1>  LOC = J23; # HDR1_4
## NET gpio_exp_hdr1<0>  LOC = J20; # HDR1_2
#NET gpio_exp_hdr1<*> TIG;
#NET gpio_exp_hdr1<*> PULLDOWN;
#NET gpio_exp_hdr1<*> IOSTANDARD = LVCMOS25;

## NET gpio_exp_hdr2<31> LOC = P21; # HDR2_64
## NET gpio_exp_hdr2<30> LOC = P20; # HDR2_62
## NET gpio_exp_hdr2<29> LOC = H24; # HDR2_60
## NET gpio_exp_hdr2<28> LOC = J24; # HDR2_58
## NET gpio_exp_hdr2<27> LOC = M20; # HDR2_56
## NET gpio_exp_hdr2<26> LOC = M19; # HDR2_54
## NET gpio_exp_hdr2<25> LOC = G24; # HDR2_52
## NET gpio_exp_hdr2<24> LOC = G25; # HDR2_50
## NET gpio_exp_hdr2<23> LOC = P23; # HDR2_48
## NET gpio_exp_hdr2<22> LOC = N23; # HDR2_46
## NET gpio_exp_hdr2<21> LOC = L20; # HDR2_44
## NET gpio_exp_hdr2<20> LOC = L19; # HDR2_42
## NET gpio_exp_hdr2<19> LOC = G26; # HDR2_40
## NET gpio_exp_hdr2<18> LOC = H26; # HDR2_38
## NET gpio_exp_hdr2<17> LOC = K23; # HDR2_36
## NET gpio_exp_hdr2<16> LOC = K22; # HDR2_34
## NET gpio_exp_hdr2<15> LOC = V26; # HDR2_32
## NET gpio_exp_hdr2<14> LOC = U26; # HDR2_30
## NET gpio_exp_hdr2<13> LOC = N22; # HDR2_28
## NET gpio_exp_hdr2<12> LOC = N21; # HDR2_26
## NET gpio_exp_hdr2<11> LOC = R22; # HDR2_24
## NET gpio_exp_hdr2<10> LOC = R23; # HDR2_22
## NET gpio_exp_hdr2<9>  LOC = J25; # HDR2_20
## NET gpio_exp_hdr2<8>  LOC = J26; # HDR2_18
## NET gpio_exp_hdr2<7>  LOC = P19; # HDR2_16
## NET gpio_exp_hdr2<6>  LOC = N19; # HDR2_14
## NET gpio_exp_hdr2<5>  LOC = G21; # HDR2_12
## NET gpio_exp_hdr2<4>  LOC = G22; # HDR2_10
## NET gpio_exp_hdr2<3>  LOC = E25; # HDR2_8
## NET gpio_exp_hdr2<2>  LOC = E26; # HDR2_6
## NET gpio_exp_hdr2<1>  LOC = F24; # HDR2_4
## NET gpio_exp_hdr2<0>  LOC = F25; # HDR2_2
## NET gpio_exp_hdr2<*> TIG;
## NET gpio_exp_hdr2<*> PULLDOWN;
## NET gpio_exp_hdr2<*> IOSTANDARD = LVCMOS25;

## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for Character LCD GPIO
## #------------------------------------------------------------------------------

## NET gpio_char_lcd<6> LOC = P6; # LCD_E
## NET gpio_char_lcd<5> LOC = R7; # LCD_RS
## NET gpio_char_lcd<4> LOC = R5; # LCD_RW
## NET gpio_char_lcd<3> LOC = P4; # LCD_DB7
## NET gpio_char_lcd<2> LOC = R3; # LCD_DB6
## NET gpio_char_lcd<1> LOC = T3; # LCD_DB5
## NET gpio_char_lcd<0> LOC = R6; # LCD_DB4
## NET gpio_char_lcd<*> IOSTANDARD = LVCMOS33;
## NET gpio_char_lcd<*> TIG;
## NET gpio_char_lcd<*> PULLDOWN;

## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for DDR Controllers
## #------------------------------------------------------------------------------

########################################################################
# Controller 0
# Memory Device: DDR2_SDRAM->SODIMMs->MT4HTF3264HY-53E #
# Data Width:     64 #
# Data Mask:     1 #
########################################################################


NET ddr2_a<0>  LOC = Y5; # DDR_A0
NET ddr2_a<1>  LOC = Y6; # DDR_A1
NET ddr2_a<2>  LOC = W6; # DDR_A2
NET ddr2_a<3>  LOC = W5; # DDR_A3
NET ddr2_a<4>  LOC = V7; # DDR_A4
NET ddr2_a<5>  LOC = V6; # DDR_A5
NET ddr2_a<6>  LOC = Y3; # DDR_A6
NET ddr2_a<7>  LOC = W3; # DDR_A7
NET ddr2_a<8>  LOC = W4; # DDR_A8
NET ddr2_a<9>  LOC = V4; # DDR_A9
NET ddr2_a<10> LOC = AD3; # DDR_A10
NET ddr2_a<11> LOC = AD4; # DDR_A11
NET ddr2_a<12> LOC = AC3; # DDR_A12
NET ddr2_ba<0>  LOC = AB5; # DDR_BA0
NET ddr2_ba<1>  LOC = AB6; # DDR_BA1
NET ddr2_cas_n   LOC = AE3; # DDR_CAS_N
NET ddr2_cke<0> LOC = AA3; # DDR_CKE
NET ddr2_cke<1> LOC = AB4; # DDR_CKE
NET ddr2_cs_n<0>  LOC = AF3; # DDR_CS_N
NET ddr2_cs_n<1>  LOC = AD6; # DDR_CS_N
NET ddr2_ras_n   LOC = AC6; # DDR_RAS_N
NET ddr2_we_n    LOC = AB7; # DDR_WE_N
NET ddr2_ck<0>    LOC = E2; # DDR_CK0_P
NET ddr2_ck_n<0>   LOC = E1; # DDR_CK0_N
NET ddr2_ck<1>    LOC = P1; # DDR_CK1_P
NET ddr2_ck_n<1>   LOC = R1; # DDR_CK1_N
NET ddr2_odt<0>  LOC =AE6; # DDR_ODT0
NET ddr2_odt<1>  LOC =AE5; # DDR_ODT1

NET ddr2_dm<0>  LOC = B9; # DDR_DM0
NET ddr2_dm<1>  LOC = A8; # DDR_DM1
NET ddr2_dm<2>  LOC = C4; # DDR_DM2
NET ddr2_dm<3>  LOC = F2; # DDR_DM3
NET ddr2_dm<4>  LOC = AB1; # DDR_DM4
NET ddr2_dm<5>  LOC = AF24; # DDR_DM5
NET ddr2_dm<6>  LOC = AF22; # DDR_DM6
NET ddr2_dm<7>  LOC = AF8; # DDR_DM7

NET ddr2_dqs<0>  LOC = B7; # DDR_DQS0
NET ddr2_dqs_n<0> LOC = A7; # DDR_DQSN0
NET ddr2_dqs<1>  LOC = D5; # DDR_DQS1
NET ddr2_dqs_n<1> LOC = D6; # DDR_DQSN1
NET ddr2_dqs<2>  LOC = C6; # DDR_DQS2
NET ddr2_dqs_n<2> LOC = C7; # DDR_DQSN2
NET ddr2_dqs<3>  LOC = M1; # DDR_DQS3
NET ddr2_dqs_n<3> LOC = N1; # DDR_DQSN3
NET ddr2_dqs<4>  LOC = T2; # DDR_DQS4
NET ddr2_dqs_n<4> LOC = R2; # DDR_DQSN4
NET ddr2_dqs<5>  LOC = AF18; # DDR_DQS5
NET ddr2_dqs_n<5> LOC = AE18; # DDR_DQSN5
NET ddr2_dqs<6>  LOC = AF19; # DDR_DQS6
NET ddr2_dqs_n<6> LOC = AF20; # DDR_DQSN6
NET ddr2_dqs<7>  LOC = AF17; # DDR_DQS7
NET ddr2_dqs_n<7> LOC = AE17; # DDR_DQSN7

NET ddr2_dq<0> LOC = C11; # DDR_D0
NET ddr2_dq<1> LOC = C13; # DDR_D1
NET ddr2_dq<2> LOC = A12; # DDR_D2
NET ddr2_dq<3> LOC = C9; # DDR_D3
NET ddr2_dq<4> LOC = D10; # DDR_D4
NET ddr2_dq<5> LOC = C12; # DDR_D5
NET ddr2_dq<6> LOC = B12; # DDR_D6
NET ddr2_dq<7> LOC = A13; # DDR_D7
NET ddr2_dq<8> LOC = A10; # DDR_D8
NET ddr2_dq<9> LOC = A9; # DDR_D9
NET ddr2_dq<10> LOC = B5; # DDR_D10
NET ddr2_dq<11> LOC = D3; # DDR_D11
NET ddr2_dq<12> LOC = B10; # DDR_D12
NET ddr2_dq<13> LOC = B11; # DDR_D13
NET ddr2_dq<14> LOC = B6; # DDR_D14
NET ddr2_dq<15> LOC = B4; # DDR_D15
NET ddr2_dq<16> LOC = C2; # DDR_D16
NET ddr2_dq<17> LOC = A2; # DDR_D17
NET ddr2_dq<18> LOC = D1; # DDR_D18
NET ddr2_dq<19> LOC = B1; # DDR_D19
NET ddr2_dq<20> LOC = C3; # DDR_D20
NET ddr2_dq<21> LOC = A3; # DDR_D21
NET ddr2_dq<22> LOC = C1; # DDR_D22
NET ddr2_dq<23> LOC = B2; # DDR_D23
NET ddr2_dq<24> LOC = F3; # DDR_D24
NET ddr2_dq<25> LOC = G1; # DDR_D25
NET ddr2_dq<26> LOC = G2; # DDR_D26
NET ddr2_dq<27> LOC = H3; # DDR_D27
NET ddr2_dq<28> LOC = E3; # DDR_D28
NET ddr2_dq<29> LOC = H1; # DDR_D29
NET ddr2_dq<30> LOC = K3; # DDR_D30
NET ddr2_dq<31> LOC = J3; # DDR_D31

NET ddr2_dq<32> LOC = Y1; # DDR_D32
NET ddr2_dq<33> LOC = Y2; # DDR_D33
NET ddr2_dq<34> LOC = AC1; # DDR_D34
NET ddr2_dq<35> LOC = AD1; # DDR_D35
NET ddr2_dq<36> LOC = AA2; # DDR_D36
NET ddr2_dq<37> LOC = AB2; # DDR_D37
NET ddr2_dq<38> LOC = AC2; # DDR_D38
NET ddr2_dq<39> LOC = AE1; # DDR_D39
NET ddr2_dq<40> LOC = AD23; # DDR_D40
NET ddr2_dq<41> LOC = AD26; # DDR_D41
NET ddr2_dq<42> LOC = AF25; # DDR_D42
NET ddr2_dq<43> LOC = AD25; # DDR_D43
NET ddr2_dq<44> LOC = AD24; # DDR_D44
NET ddr2_dq<45> LOC = AE26; # DDR_D45
NET ddr2_dq<46> LOC = AE25; # DDR_D46
NET ddr2_dq<47> LOC = AF23; # DDR_D47
NET ddr2_dq<48> LOC = AD20; # DDR_D48
NET ddr2_dq<49> LOC = AE20; # DDR_D49
NET ddr2_dq<50> LOC = AF14; # DDR_D50
NET ddr2_dq<51> LOC = AF12; # DDR_D51
NET ddr2_dq<52> LOC = AD21; # DDR_D52
NET ddr2_dq<53> LOC = AE21; # DDR_D53
NET ddr2_dq<54> LOC = AF13; # DDR_D54
NET ddr2_dq<55> LOC = AE12; # DDR_D55
NET ddr2_dq<56> LOC = AE11; # DDR_D56
NET ddr2_dq<57> LOC = AE10; # DDR_D57
NET ddr2_dq<58> LOC = AF7; # DDR_D58
NET ddr2_dq<59> LOC = AE7; # DDR_D59
NET ddr2_dq<60> LOC = AF10; # DDR_D60
NET ddr2_dq<61> LOC = AF9; # DDR_D61
NET ddr2_dq<62> LOC = AE8; # DDR_D62
NET ddr2_dq<63> LOC = AD9; # DDR_D63

NET ddr2_a<*>   IOSTANDARD = SSTL18_II;
NET ddr2_ba<*>   IOSTANDARD = SSTL18_II;
NET ddr2_cke<*>  IOSTANDARD = SSTL18_II;
NET ddr2_cas_n    IOSTANDARD = SSTL18_II;
NET ddr2_cs_n<*>  IOSTANDARD = SSTL18_II;
NET ddr2_ras_n    IOSTANDARD = SSTL18_II;
NET ddr2_we_n     IOSTANDARD = SSTL18_II;
NET ddr2_odt<*>  IOSTANDARD = SSTL18_II;

NET ddr2_dm<*>   IOSTANDARD = SSTL18_II_DCI;
NET ddr2_dq<*>   IOSTANDARD = SSTL18_II_DCI;

NET ddr2_ck<*>  IOSTANDARD = DIFF_SSTL18_II;
NET ddr2_ck_n<*> IOSTANDARD = DIFF_SSTL18_II;
NET ddr2_dqs<*>  IOSTANDARD = DIFF_SSTL18_II_DCI;
NET ddr2_dqs_n<*> IOSTANDARD = DIFF_SSTL18_II_DCI;

## NET "ddr2_cal_clk"   TNM_NET = "ddr2_cal_clk";
## NET "ddr2_dev_clk_*" TNM_NET = "ddr2_dev_clk";
## TIMESPEC "TSCAL_DEV" = FROM "ddr2_cal_clk" TO "ddr2_dev_clk" TIG;
## TIMESPEC "TSDEV_CAL" = FROM "ddr2_dev_clk" TO "ddr2_cal_clk" TIG;
###############################################################################
# Define multicycle paths - these paths may take longer because additional
# time allowed for logic to settle in calibration/initialization FSM
###############################################################################

# MIG 2.1: Eliminate Timegroup definitions for CLK0, and CLK90. Instead trace
#          multicycle paths from originating flip-flop to ANY destination
#          flip-flop (or in some cases, it can also be a BRAM)
# MUX Select for either rising/falling CLK0 for 2nd stage read capture
INST "*/u_phy_calib/gen_rd_data_sel*.u_ff_rd_data_sel" TNM = "TNM_RD_DATA_SEL";
TIMESPEC "TS_MC_RD_DATA_SEL" = FROM "TNM_RD_DATA_SEL" TO FFS
"TS_SYS_CLK" * 4;
# MUX select for read data - optional delay on data to account for byte skews
INST "*/u_usr_rd/gen_rden_sel_mux*.u_ff_rden_sel_mux" TNM = "TNM_RDEN_SEL_MUX";
TIMESPEC "TS_MC_RDEN_SEL_MUX" = FROM "TNM_RDEN_SEL_MUX" TO FFS
"TS_SYS_CLK" * 4;
# Calibration/Initialization complete status flag (for PHY logic only) - can
# be used to drive both flip-flops and BRAMs
INST "*/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_DATA_SEL";
TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_0" = FROM "TNM_PHY_INIT_DATA_SEL" TO FFS
"TS_SYS_CLK" * 4;
TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_90" = FROM "TNM_PHY_INIT_DATA_SEL" TO RAMS
"TS_SYS_CLK" * 4;
# Select (address) bits for SRL32 shift registers used in stage3/stage4
# calibration
INST "*/u_phy_calib/gen_gate_dly*.u_ff_gate_dly" TNM = "TNM_GATE_DLY";
TIMESPEC "TS_MC_GATE_DLY" = FROM "TNM_GATE_DLY" TO FFS "TS_SYS_CLK" * 4;

INST "*/u_phy_calib/gen_rden_dly*.u_ff_rden_dly" TNM = "TNM_RDEN_DLY";
TIMESPEC "TS_MC_RDEN_DLY" = FROM "TNM_RDEN_DLY" TO FFS "TS_SYS_CLK" * 4;

INST "*/u_phy_calib/gen_cal_rden_dly*.u_ff_cal_rden_dly"
  TNM = "TNM_CAL_RDEN_DLY";
TIMESPEC "TS_MC_CAL_RDEN_DLY" = FROM "TNM_CAL_RDEN_DLY" TO FFS
"TS_SYS_CLK" * 4;


###############################################################################
# DQS Read Post amble Glitch Squelch circuit related constraints
###############################################################################

###############################################################################
# LOC placement of DQS-squelch related IDDR and IDELAY elements
# Each circuit can be located at any of the following locations:
#  1. Unused "N"-side of DQS differential pair I/O
#  2. DM data mask (output only, input side is free for use)
#  3. Any output-only site
###############################################################################

#INST "*/gen_dqs[0].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y182";
#INST "*/gen_dqs[0].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y182";
#INST "*/gen_dqs[1].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y180";
#INST "*/gen_dqs[1].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y180";
#INST "*/gen_dqs[2].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y178";
#INST "*/gen_dqs[2].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y178";
#INST "*/gen_dqs[3].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y142";
#INST "*/gen_dqs[3].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y142";
#INST "*/gen_dqs[4].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y140";
#INST "*/gen_dqs[4].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y140";
#INST "*/gen_dqs[5].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y138";
#INST "*/gen_dqs[5].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y138";
#INST "*/gen_dqs[6].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y102";
#INST "*/gen_dqs[6].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y102";
#INST "*/gen_dqs[7].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y100";
#INST "*/gen_dqs[7].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y100";

###############################################################################
# LOC and timing constraints for flop driving DQS CE enable signal
# from fabric logic. Even though the absolute delay on this path is
# calibrated out (when synchronizing this output to DQS), the delay
# should still be kept as low as possible to reduce post-calibration
# voltage/temp variations - these are roughly proportional to the
# absolute delay of the path
###############################################################################
INST "*/u_phy_calib/gen_gate[0].u_en_dqs_ff"  LOC = SLICE_X0Y91;
INST "*/u_phy_calib/gen_gate[1].u_en_dqs_ff"  LOC = SLICE_X0Y90;
INST "*/u_phy_calib/gen_gate[2].u_en_dqs_ff"  LOC = SLICE_X0Y89;
INST "*/u_phy_calib/gen_gate[3].u_en_dqs_ff"  LOC = SLICE_X0Y71;
INST "*/u_phy_calib/gen_gate[4].u_en_dqs_ff"  LOC = SLICE_X0Y70;
INST "*/u_phy_calib/gen_gate[5].u_en_dqs_ff"  LOC = SLICE_X0Y69;
INST "*/u_phy_calib/gen_gate[6].u_en_dqs_ff"  LOC = SLICE_X0Y51;
INST "*/u_phy_calib/gen_gate[7].u_en_dqs_ff"  LOC = SLICE_X0Y50;

# Control for DQS gate - from fabric flop. Prevent "runaway" delay -
# two parts to this path: (1) from fabric flop to IDELAY, (2) from
# IDELAY to asynchronous reset of IDDR that drives the DQ CE's
# This can be relaxed by the user for lower frequencies:
# 300MHz = 850ps, 267MHz = 900ps. At 200MHz = 950ps.
# In general PAR should be able to route this
# within 900ps over all speed grades.
#NET "*/u_phy_io/en_dqs*" MAXDELAY = 900 ps;
# JB: Every single one failed with < 2ns slack!! Try upping this...
NET "*/u_phy_io/en_dqs*" MAXDELAY = 3000 ps;
NET "*/u_phy_io/gen_dqs*.u_iob_dqs/en_dqs_sync" MAXDELAY = 850 ps;

###############################################################################
# Define multicycle paths - these paths may take longer because additional
# time allowed for logic to settle in calibration/initialization FSM
###############################################################################
## DDR2 clock domain nets
NET "*/xilinx_ddr2_if0/ddr2_read_done" TNM_NET = "DDR2_READ_DONE_GRP";
NET "*/xilinx_ddr2_if0/ddr2_write_done" TNM_NET = "DDR2_WRITE_DONE_GRP";


TIMEGRP "DDR2_MC_REGS" = "DDR2_READ_DONE_GRP" "DDR2_WRITE_DONE_GRP";
## System bus (wishbone) domain nets
NET "*/xilinx_ddr2_if0/do_writeback*" TNM_NET = "WB_DO_WRITEBACK";
NET "*/xilinx_ddr2_if0/do_readfrom*" TNM_NET = "WB_DO_READFROM";

TIMEGRP "WB_MC_REGS" = "WB_DO_WRITEBACK" "WB_DO_READFROM";

# Path constraints - if bus clock is 50Mhz they have 20ns
TIMESPEC TS_ddr2_controller_mc_paths = FROM "WB_MC_REGS" to "DDR2_MC_REGS" 20ns;
TIMESPEC TS_ddr2_controller_mc_paths2 = FROM "DDR2_MC_REGS" to "WB_MC_REGS" 20ns;

###############################################################################
# "Half-cycle" path constraint from IDDR to CE pin for all DQ IDDR's
# for DQS Read Post amble Glitch Squelch circuit
###############################################################################

# Max delay from output of IDDR to CE input of DQ IDDRs = tRPST + some slack
#  where slack account for rise-time of DQS on board. For now assume slack = 
#  0.400ns (based on initial SPICE simulations, assumes use of ODT), so 
#  time = 0.4*Tcyc + 0.40ns = 1.6ns @333MHz
INST "*/gen_dqs[*].u_iob_dqs/u_iddr_dq_ce" TNM = "TNM_DQ_CE_IDDR";
INST "*/gen_dq[*].u_iob_dq/gen_stg2_*.u_iddr_dq" TNM = "TNM_DQS_FLOPS";
#TIMESPEC "TS_DQ_CE" = FROM "TNM_DQ_CE_IDDR" TO "TNM_DQS_FLOPS" 2.4 ns;
# JB:  Was very closely failing on some paths, so up it by 100ps, but note it as an issue!
TIMESPEC "TS_DQ_CE" = FROM "TNM_DQ_CE_IDDR" TO "TNM_DQS_FLOPS" 2.5 ns;


## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for UART
## #------------------------------------------------------------------------------

#NET uart_RX LOC = AC7;
#NET uart_RX IOSTANDARD = LVCMOS33;
#NET uart_RX TIG;
#NET uart_TX LOC = AD14;
#NET uart_TX IOSTANDARD = LVCMOS33;
#NET uart_TX TIG;

NET uart0_srx_pad_i LOC = AC7;
NET uart0_srx_pad_i IOSTANDARD = LVCMOS33;
NET uart0_srx_pad_i TIG;
NET uart0_stx_pad_o LOC = AD14;
NET uart0_stx_pad_o IOSTANDARD = LVCMOS33;
NET uart0_stx_pad_o TIG;

## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for SRAM
## #------------------------------------------------------------------------------

#NET sram_clk            LOC = U22;
#NET sram_clk_fb         LOC = AD15;
#NET sram_clk_fb         IOSTANDARD = LVCMOS33;
#NET sram_clk            IOSTANDARD = LVDCI_33;

#NET sram_clk_fb FEEDBACK = 1500ps NET sram_clk;

##NET sram_flash_addr<23> LOC = Y10;
##NET sram_flash_addr<22> LOC = Y11;
#NET sram_flash_addr<21> LOC = AA17;
#NET sram_flash_addr<20> LOC = AB17;
#NET sram_flash_addr<19> LOC = G14;
#NET sram_flash_addr<18> LOC = F13;
#NET sram_flash_addr<17> LOC = H14;
#NET sram_flash_addr<16> LOC = H13;
#NET sram_flash_addr<15> LOC = F15;
#NET sram_flash_addr<14> LOC = G15;
#NET sram_flash_addr<13> LOC = G12;
#NET sram_flash_addr<12> LOC = H12;
#NET sram_flash_addr<11> LOC = G16;
#NET sram_flash_addr<10> LOC = H16;
#NET sram_flash_addr<9>  LOC = H11;
#NET sram_flash_addr<8>  LOC = G11;
#NET sram_flash_addr<7>  LOC = H17;
#NET sram_flash_addr<6>  LOC = G17;
#NET sram_flash_addr<5>  LOC = G10;
#NET sram_flash_addr<4>  LOC = G9;
#NET sram_flash_addr<3>  LOC = G19;
#NET sram_flash_addr<2>  LOC = H18;
#NET sram_flash_addr<1>  LOC = H9;
##NET sram_flash_addr<0>  LOC = H8;
#NET sram_flash_addr<*>  IOSTANDARD = LVCMOS33;
#NET sram_flash_addr<*>  SLEW = FAST;
#NET sram_flash_addr<*>  DRIVE = 8;

#NET sram_flash_data<31> LOC = AD18 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<30> LOC = AC18 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<29> LOC = AB10 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<28> LOC = AB9  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<27> LOC = AC17 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<26> LOC = AC16 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<25> LOC = AC8  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<24> LOC = AC9  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<23> LOC = Y12  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<22> LOC = Y13  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<21> LOC = AA15 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<20> LOC = AB14 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<19> LOC = AA12 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<18> LOC = AB11 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<17> LOC = AA13 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_data<16> LOC = AA14 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;

#NET sram_flash_data<15> LOC = AC24 | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<14> LOC = AB22 | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<13> LOC = AA22 | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<12> LOC = AC21 | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<11> LOC = AB21 | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<10> LOC = W21  | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<9>  LOC = W20  | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<8>  LOC = U19  | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<7>  LOC = U20  | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<6>  LOC = V19  | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<5>  LOC = W19  | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<4>  LOC = Y21  | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<3>  LOC = Y20  | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<2>  LOC = AD19 | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<1>  LOC = AC19 | IOSTANDARD = LVDCI_33;
#NET sram_flash_data<0>  LOC = AB20 | IOSTANDARD = LVDCI_33;

#NET sram_flash_data<*> PULLDOWN;

#NET sram_cen            LOC = AB24 | IOSTANDARD = LVDCI_33;
#NET sram_flash_oe_n           LOC = AC22 | IOSTANDARD = LVDCI_33;
##NET flash_oe_n          LOC = AA9  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_flash_we_n     LOC = AB15 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_bw<3>          LOC = W24  | IOSTANDARD = LVDCI_33; 
#NET sram_bw<2>          LOC = W23  | IOSTANDARD = LVDCI_33; 
#NET sram_bw<1>          LOC = V24  | IOSTANDARD = LVDCI_33;  
#NET sram_bw<0>          LOC = V23  | IOSTANDARD = LVDCI_33; 
##NET flash_cen           LOC = AA10 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
#NET sram_adv_ld_n       LOC = U21  | IOSTANDARD = LVDCI_33;
#NET sram_mode           LOC = AC23 | IOSTANDARD = LVDCI_33;
# NET flash_audio_reset_n LOC = AD10 | IOSTANDARD = LVCMOS33;


## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for CFI Flash (shared with SRAM)
## #------------------------------------------------------------------------------ 
NET flash_adr_o<23> LOC = Y10;
NET flash_adr_o<22> LOC = Y11;
NET flash_adr_o<21> LOC = AA17;
NET flash_adr_o<20> LOC = AB17;
NET flash_adr_o<19> LOC = G14;
NET flash_adr_o<18> LOC = F13;
NET flash_adr_o<17> LOC = H14;
NET flash_adr_o<16> LOC = H13;
NET flash_adr_o<15> LOC = F15;
NET flash_adr_o<14> LOC = G15;
NET flash_adr_o<13> LOC = G12;
NET flash_adr_o<12> LOC = H12;
NET flash_adr_o<11> LOC = G16;
NET flash_adr_o<10> LOC = H16;
NET flash_adr_o<9>  LOC = H11;
NET flash_adr_o<8>  LOC = G11;
NET flash_adr_o<7>  LOC = H17;
NET flash_adr_o<6>  LOC = G17;
NET flash_adr_o<5>  LOC = G10;
NET flash_adr_o<4>  LOC = G9;
NET flash_adr_o<3>  LOC = G19;
NET flash_adr_o<2>  LOC = H18;
NET flash_adr_o<1>  LOC = H9;
NET flash_adr_o<0>  LOC = H8;
NET flash_adr_o<*>  IOSTANDARD = LVCMOS33;
NET flash_adr_o<*>  SLEW = FAST;
NET flash_adr_o<*>  DRIVE = 8;


NET flash_dq_io<15> LOC = AD18 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<14> LOC = AC18 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<13> LOC = AB10 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<12> LOC = AB9  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<11> LOC = AC17 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<10> LOC = AC16 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<9> LOC = AC8  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<8> LOC = AC9  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<7> LOC = Y12  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<6> LOC = Y13  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<5> LOC = AA15 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<4> LOC = AB14 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<3> LOC = AA12 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<2> LOC = AB11 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<1> LOC = AA13 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_dq_io<0> LOC = AA14 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW  = FAST;

NET flash_dq_io<*> PULLDOWN;

NET flash_adv_n_o   LOC = AA20  | IOSTANDARD = LVCMOS33;
NET flash_oe_n_o    LOC = AA9  | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_we_n_o    LOC = AB15 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_ce_n_o    LOC = AA10 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_clk_o     LOC = AB19 | IOSTANDARD = LVCMOS33 | DRIVE = 12 | SLEW = FAST;
NET flash_wait_i    LOC = AA19 | IOSTANDARD = LVCMOS33;
NET flash_rst_n_o   LOC = AD10 | IOSTANDARD = LVCMOS33;

#------------------------------------------------------------------------------
# IO Pad Location Constraints / Properties for TFT VGA LCD Controller
#------------------------------------------------------------------------------

#NET dvi_iic_scl  LOC = D21;
#NET dvi_iic_sda  LOC = D20;
#NET dvi_iic_scl  SLEW = SLOW;
#NET dvi_iic_scl  DRIVE = 6;
#NET dvi_iic_scl  TIG;
#NET dvi_iic_scl  IOSTANDARD = LVCMOS33;
#NET dvi_iic_sda  SLEW = SLOW;
#NET dvi_iic_sda  DRIVE = 6;
#NET dvi_iic_sda  TIG;
#NET dvi_iic_sda  IOSTANDARD = LVCMOS33;

#NET tft_lcd_data<0>  LOC = A17; 
#NET tft_lcd_data<1>  LOC = B17; 
#NET tft_lcd_data<2>  LOC = C17; 
#NET tft_lcd_data<3>  LOC = D18; 
#NET tft_lcd_data<4>  LOC = C16; 
#NET tft_lcd_data<5>  LOC = D16; 
#NET tft_lcd_data<6>  LOC = B16; 
#NET tft_lcd_data<7>  LOC = B15; 
#NET tft_lcd_data<8>  LOC = A15; 
#NET tft_lcd_data<9>  LOC = A14; 
#NET tft_lcd_data<10> LOC = B14; 
#NET tft_lcd_data<11> LOC = C14; 
#NET tft_lcd_data<*> IOSTANDARD = LVDCI_33;

#NET tft_lcd_clk_p LOC = A20;
#NET tft_lcd_clk_p IOSTANDARD = LVCMOS33 | DRIVE = 24 | SLEW = FAST;
#NET tft_lcd_clk_n LOC = B20;
#NET tft_lcd_clk_n IOSTANDARD = LVCMOS33 | DRIVE = 24 | SLEW = FAST;

#NET tft_lcd_hsync LOC = C19;
#NET tft_lcd_hsync IOSTANDARD = LVDCI_33;
#NET tft_lcd_vsync LOC = D19;
#NET tft_lcd_vsync IOSTANDARD = LVDCI_33;
#NET tft_lcd_de    LOC = C18;
#NET tft_lcd_de    IOSTANDARD = LVDCI_33;
#NET tft_lcd_reset_b LOC = A18;
#NET tft_lcd_reset_b IOSTANDARD = LVCMOS33;

## NET "tft_clk"  TNM_NET = "tft_clk";
## TIMESPEC "TSPLB_TFT" = FROM "sys_clk" TO "tft_clk" TIG;
## TIMESPEC "TSTFT_PLB" = FROM "tft_clk" TO "sys_clk" TIG;

## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for Ethernet
## #------------------------------------------------------------------------------

NET eth0_col        LOC = G20 | IOSTANDARD = LVCMOS25;
NET eth0_crs        LOC = H22 | IOSTANDARD = LVCMOS25;
NET eth0_dv         LOC = J19 | IOSTANDARD = LVCMOS25;
NET eth0_rx_clk     LOC = F14 | IOSTANDARD = LVCMOS25;
NET eth0_rx_data<3> LOC = E22 | IOSTANDARD = LVCMOS25;
NET eth0_rx_data<2> LOC = E20 | IOSTANDARD = LVCMOS25;
NET eth0_rx_data<1> LOC = E21 | IOSTANDARD = LVCMOS25;
NET eth0_rx_data<0> LOC = F20 | IOSTANDARD = LVCMOS25;

NET eth0_rx_er      LOC = H19 | IOSTANDARD = LVCMOS25;
NET eth0_tx_clk     LOC = D13 | IOSTANDARD = LVCMOS25;
#NET eth0_mii_int_n  LOC = F17 | IOSTANDARD = LVCMOS25;
NET eth0_rst_n_o      LOC = F8  | IOSTANDARD = LVCMOS25 | PULLUP; # PHY_RESET pin on phy
NET eth0_tx_data<3> LOC = B25 | IOSTANDARD = LVDCI_33;
NET eth0_tx_data<2> LOC = C24 | IOSTANDARD = LVDCI_33;
NET eth0_tx_data<1> LOC = D24 | IOSTANDARD = LVDCI_33;
NET eth0_tx_data<0> LOC = C23 | IOSTANDARD = LVDCI_33;
NET eth0_tx_en      LOC = B24 | IOSTANDARD = LVDCI_33;
NET eth0_tx_er      LOC = A24 | IOSTANDARD = LVDCI_33;

## PHY Serial Management Interface pins
NET eth0_mdc_pad_o    LOC = F18 | IOSTANDARD = LVCMOS25;
NET eth0_md_pad_io   LOC = E8  | IOSTANDARD = LVCMOS25;

## NET phy_mii_int_n  PULLUP;

## NET phy_mii_int_n  TIG;
NET eth0_rst_n_o      TIG;

## # Timing Constraints (these are recommended in documentation and
## # are unaltered except for the TIG)
#NET "eth0_rx_clk" TNM_NET = "RXCLK_GRP";
NET "eth0_rx_clk_BUFGP" TNM_NET = "RXCLK_GRP";
#NET "eth0_tx_clk" TNM_NET = "TXCLK_GRP";
NET "eth0_tx_clk_BUFGP" TNM_NET = "TXCLK_GRP";
TIMESPEC "TSTXOUT" = FROM "TXCLK_GRP" TO "PADS" 10 ns;
TIMESPEC "TSRXIN" = FROM "PADS" TO "RXCLK_GRP" 6 ns;

NET "eth0_rx_data<3>" IOBDELAY=NONE;
NET "eth0_rx_data<2>" IOBDELAY=NONE;
NET "eth0_rx_data<1>" IOBDELAY=NONE;
NET "eth0_rx_data<0>" IOBDELAY=NONE;
NET "eth0_dv" IOBDELAY=NONE;
NET "eth0_rx_er" IOBDELAY=NONE;
NET "eth0_crs" IOBDELAY=NONE;
NET "eth0_col" IOBDELAY=NONE;

## # Timing ignores (to specify unconstrained paths)
NET "wb_clk" TNM_NET = "wb_clk_grp"; # Wishbone clock
TIMESPEC "TS_PHYTX_OPB" = FROM "TXCLK_GRP" TO "wb_clk_grp" TIG;
TIMESPEC "TS_OPB_PHYTX" = FROM "wb_clk_grp" TO "TXCLK_GRP" TIG;
TIMESPEC "TS_PHYRX_OPB" = FROM "RXCLK_GRP" TO "wb_clk_grp" TIG;
TIMESPEC "TS_OPB_PHYRX" = FROM "wb_clk_grp" TO "RXCLK_GRP" TIG;

## #------------------------------------------------------------------------------
## # IO Pad Location Constraints / Properties for AC97 Sound Controller
## #------------------------------------------------------------------------------

## NET ac97_bit_clk   LOC = AC13;
## NET ac97_bit_clk   IOSTANDARD = LVCMOS33;
## NET ac97_bit_clk   PERIOD = 80;
## NET ac97_sdata_in  LOC = AC12;
## NET ac97_sdata_in  IOSTANDARD = LVCMOS33;
## NET ac97_sdata_out LOC = AC11;
## NET ac97_sdata_out IOSTANDARD = LVCMOS33;
## NET ac97_sync      LOC = AD11;
## NET ac97_sync      IOSTANDARD = LVCMOS33;
